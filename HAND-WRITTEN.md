# Virtual Energy Trader Development Journey

## Project Inception

The project began with the email exchange with Joshua, which detailed the initial project idea. I took the email and fed it to Grok (using Grok 3 model) to conduct some engineering work and develop the project plan (documented in `prompts/Project Plan (Grok).md`). This eventually led to creating a comprehensive prompt suitable for Bolt (documented in `prompts/One Shot Prompt (Bolt).md`).

## Initial Development with Bolt

### Budget and Technical Constraints

After creating the one-shot prompt, I asked Bolt to build the application. I quickly realized I didn't have enough budget, so I had to create a burner account to get additional resources. Interestingly, although the original email mentioned a different stack and packages, Bolt ignored these instructions. This was uncharted territory for me, and I discovered that Bolt's system prompt (`.bolt/prompt`) mentions a different stack by default, and their instructions pre-seed ours. To ensure Bolt provided good responses and to remain hackathon-compliant, I refrained from changing their prompt.

### Feature Scope Expansion

The original email mentioned choosing just a single idea, but by the end, the prompt detailed all the ideas. I felt confident about them and let the system work fairly autonomously, wanting to ensure it tried all three ideas, hoping at least one part would work well.

## API Integration Challenges

### GridStatus API Integration

The initial code worked, but only with mock data. I needed to replace the mock data with actual GridStatus APIs. I started pasting GridStatus documentation into Bolt to help it understand the API. Since GridStatus didn't have a Node.js package, I had to build different cases using:

- [Dataset Metadata](https://docs.gridstatus.io/developers/api-reference/dataset-metadata)
- [Query Data](https://docs.gridstatus.io/developers/api-reference/query-data)

I couldn't use [Reports](https://docs.gridstatus.io/developers/api-reference/reports) as it's only accessible on the paid plan.

### LLM Integration

Once I established the GridStatus connection, integrating LLMs didn't require much effort. This was primarily because I had previous experience working on a "1 day, 1 idea" project where I successfully connected to LLMs using Langchain on the client-side (see: <https://gilded-gecko-b88f45.netlify.app/>). Moving this logic was just a matter of cherry-picking and asking Bolt to add it to the backend.

However, neither the email nor the plan detailed how to use the LLMs comprehensively. I knew making it work as expected would be challenging. While I have LLM-related code, it might not integrate fully into the system, primarily because I have limited knowledge of the actual data from GridStatus and how to trigger spikes. Pair-programming would be required to make this feature-rich, along with the spike-detection logic.

## Rate Limiting and Caching Solutions

### The Challenge

Connecting the APIs and dropping the mock data seemed straightforward, but I encountered problems, primarily with GridStatus. Using the free plan meant dealing with usage and rate limits.

### My Solutions

1. **Caching Logic**: I added caching logic and APIs to ensure I wasn't exceeding available resources
2. **Rate Limit Management**: I cached the dataset and tracked last request times to maintain intervals between requests
3. **Backoff Strategy**: I implemented a simple backoff-time approach instead of over-engineering with queuing or circuit breaker logic

The responses were limited, so to avoid exceeding limits, I decided to use interpolated and fallback hours with actual hours at fixed prices.

## Frontend Data Integration

I ensured data was properly sent to the client and displayed as received. The main requirement was ensuring users selected a date, then showing the data information from GridStatus with graphs for hourly comparison and additional insights.

## Trading Simulation

The simulation logic generated by the AI appeared pristine once I solved the GridStatus integration and remained mostly untouched. The code needs review and logic improvements to make it a worthy trading simulation. The simulation UI was extremely straightforward - users add bids (buy/sell signals) and run simulations to get trading results. I encountered several issues here, but clicking "Fix" in Bolt resolved them.

## Analysis Features

The analysis section was fairly autonomous, with some bug-squashing done by Bolt and APIs sending responses for spikes. As mentioned earlier, this task needs pair-programming to plan and execute properly, so it mostly remains untouched and unsolved.

## Code Refactoring

### Decision Point

After spending about 6M tokens and 5 hours with partial hyper-focus, I had working code but it was full of "slop." Ignoring the request to use CVector's stack, I decided to keep my existing setup: JS+Express for server and TS+React+Recharts for client.

### Refactoring Process

I used AI to refactor the codebase by asking ChatGPT to create Bolt-compliant prompts for refactoring both:

- Client (`prompts/refactor/Frontend (ChatGPT).md`)
- Server (`prompts/refactor/Backend (ChatGPT).md`)

This took additional time and 2M tokens, but I got refactored code. The code was beautiful but broke several pieces. By this point, I knew exactly what to do, so it was just about fixing them.

### Challenges and Improvements

The biggest challenge was Bolt's broken UX - I couldn't access diffs, previous versions, or previous chats. So, after some manual adjustment, it worked. I had to further improved DRY patterns, either by asking the AI or doing it myself.

**Key improvements:**

- **Server**: Much more readable code with additional error handling and logging
- **Frontend**: Introduction of react-query provided opportunities to cache and control API calls, further reducing the chance of hitting rate-limited GridStatus APIs

Not much changed in the frontend, showing that Bolt excels at frontend tasks. However, strict type checking was missing, requiring me to check each line of code for fixes. Due to time constraints, I decided not to work further on the client.

## Deployment Challenges

### The Hellish Part

Deployment and extracting code into a GitHub repo sounds simple, but this was the most challenging part. The primary problem was deciding where to deploy. While Netlify already worked for the client, I needed a solution for the server.

### Netlify Functions Approach

I decided to deploy everything to Netlify using [Netlify Functions](https://docs.netlify.com/functions/get-started/?fn-language=js).

This was easier said than done. I tried using serverless-http, but the code generated by Bolt was sloppy and duplicated everything from the Express app. While it would have worked, it meant all my added functionality was only active in dev mode. Bolt in itself was unable to understand the netlify docs and how to make things work.

### Moving to External Development

I tried adding the Express App on Netlify using their [Express framework guide](https://docs.netlify.com/frameworks/express/), which was painful. I decided to move outside Bolt by connecting it to GitHub and moving to my editor, where I pair-programmed with Claude (documented in `CLAUDE.md`).

**Challenges faced:**

- Had to drop some packages (e.g., `express-rate-limit`) to work serverless
- Fiddled between .mjs and .js file extensions
- Latest versions weren't getting deployed
- Extensive work with `netlify.toml` and `api.js`

### Budget and Performance Issues

I exhausted the GridStatus budget for the month. After creating a new account and getting a new API, I encountered [Netlify function limits](https://answers.netlify.com/t/serverless-functions-limits/36204/), requiring me to complete operations in less than 10 seconds.

**Solutions implemented:**

- Modified GridStatus requests
- Changed code to handle promises (noting that caching logic was no longer valid due to cold starts)
- Set 8-second timeouts for Axios retries
- Implemented react-query retries and backoff logic

What started as the simplest solution led to a spiral of problems. I exceeded the 10-hour mark and moved to another day.

## Documentation

With everything working (production, backend), only documentation remained. I asked Claude to write documentation for each server and client folder, then asked it to write the main README based on them. After some manual work, I had everything ready.

## Project Summary

**Total Resources Used:**

- **Time**: 12+ hours
- **Bolt Tokens**: 8M
- **Claude Tokens**: 300K

**Final Result**: A submitted project with working virtual energy trading functionality.
